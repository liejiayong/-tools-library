/**
 * 正则表达式：要么匹配字符，要么匹配位置
 * 
 * 贪婪：
 *  贪婪量词（{n,m}）(尽可能多匹配，如：{n,m}会匹配m个，不符合则尝试n个，期间会产生回溯)；
 * 
 * 惰性：
 *  惰性量词（?）(尽可能少的匹配, 期间可能产生回溯)；
 *  分支（a|b）(满足前面则停止匹配)
 * 
 * 简单总结就是，正因为有多种可能，所以要一个一个试。直到，要么到某一步时，整体匹配成功了；要么最后都试完后，发现整体匹配不成功。
 * 
 * 贪婪量词“试”的策略是：买衣服砍价。价钱太高了，便宜点，不行，再便宜点。
 * 
 * 惰性量词“试”的策略是：卖东西加价。给少了，再多给点行不，还有点少啊，再给点。
 * 
 * 分支结构“试”的策略是：货比三家。这家不行，换一家吧，还不行，再换。
 * 
 * 既然有回溯的过程，那么匹配效率肯定低一些。相对谁呢？
 * 
 * 相对那些DFA引擎。而JS的正则引擎是NFA，NFA是“非确定型有限自动机”的简写。
 * 
 * 大部分语言中的正则都是NFA，为啥它这么流行呢？
 * 
 * 答：你别看我匹配慢，但是我编译快啊，而且我还有趣哦。
 */

var regExpUtil = {
  idCard: '/^(\d{15}|\d{17}[\dxX])$/',
  ipv4: '/^((0{0,2}\d|0?\d{2}|1\d{2}|2[0-4]\d|25[0-5])\.){3}(0{0,2}\d|0?\d{2}|1\d{2}|2[0-4]\d|25[0-5])$/',
  pwd: '/(?!^[0-9]{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[0-9A-Za-z]{6,12}$/' // 密码长度6-12位，由数字、小写字符和大写字母组成，但必须至少包括2种字符
}